in builtins

mod BASIC-TYPES is
  --- Represents the set of basic types like integers and booleans.
  sort BasicType .
  ops int bool : -> BasicType .
endm

parse int .
parse bool .

mod SYSTEM-F-SYNTAX is including PL-ID + BASIC-TYPES .
  sort TypeVar .
  subsort Id < TypeVar .

  sort Type .
  subsorts BasicType TypeVar < Type .

  op _->_ : Type Type -> Type [gather (e E)] . --- right associative
  op \/_._ : TypeVar Type -> Type [prec 50] .

  sort Var . subsort Id < Var .

  sort Exp . subsort Var < Exp .
  --- Lambda abstraction with explicit type annotations
  op /\_:_._ : Var Type Exp -> Exp [prec 50] .
  --- Lambda expression parameterized by a type variable
  op /\_._ : TypeVar Exp -> Exp [prec 50] .
  --- Lambda Application
  op __ : Exp Exp -> Exp [prec 25 gather(E e)] . --- left associative, binds tighter than lambda abstractions
  --- Type application
  op _[_] : Exp Type -> Exp .
endm

parse (int -> int) -> bool .
parse \/ s . s .
parse \/ s . s -> s .
parse \/ s . \/ t . s -> t .
parse /\ x : int -> int . x y .
--- TODO: this is not type checked as an expression, but also does not raise a parse error
parse /\ x : int . x -> x .
parse /\ s . /\ x : s . x .
parse /\ s . /\ x : s . /\ y : int . x y .
parse (/\ s . /\ x : s . x)[int] .
parse (/\ s . /\ x : s . x)[int -> int] .

mod TYPE-ASSIGNMENT is including SYSTEM-F-SYNTAX .
  --- TypeVariables contains a list or a set of type variables
  sort TypeVariables . subsorts TypeVar < TypeVariables .
  op epsilon : -> TypeVariables .
  op _;_ : TypeVariables TypeVariables -> TypeVariables [assoc comm id: epsilon format(d s s d)] .

  --- TypeAssignment (TA) is a list of type assignment to variables
  --- It is a map from variables to their types
  --- It is a design choice to separate the type assignment from the list of type variables
  sort TypeAssignment .
  op _|->_ : Var Type -> TypeAssignment [prec 0] .
  op .TA : -> TypeAssignment .
  op _&_ : TypeAssignment TypeAssignment -> TypeAssignment [assoc comm id: .TA format(d s s d)] .

  op _(_) : TypeAssignment Var -> Type [prec 0] .          --- lookup
  op _[_/_] : TypeAssignment Type Var -> TypeAssignment [prec 0] .  --- update

  var Sigma : TypeAssignment .  var T T' : Type .  var X X' : Var .

  eq X |-> undefined = .TA .                 --- "undefine" a variable in a state

  eq (Sigma & X |-> T)(X) = T .
  eq Sigma(X) = undefined [owise] .

  eq (Sigma &  X |-> T)[T' / X ] = (Sigma & X |-> T') .
  eq Sigma[T / X] = (Sigma & X |-> T) [owise] .
endm

reduce epsilon .
reduce s ; epsilon .
reduce t ; s ; t ; epsilon .

reduce .TA .
reduce x |-> (int -> int) .
reduce x |-> (int -> int) & y |-> int .
reduce (x |-> (int -> int) & y |-> int)(x) .
reduce (x |-> (int -> int) & y |-> int)(z) .
reduce (x |-> (int -> int) & y |-> int)[bool / x] .
reduce (x |-> (int -> int) & y |-> int)[bool / x](x) .

mod SUBSTITUTION is
  including SYSTEM-F-SYNTAX .
  including PL-GENERIC-SUBSTITUTION .
  --- So far, only substitution on types is needed
  subsort Type < GenericTerm .
  eq bind('\/_._) = 1 .
  op _{_/_} : Type Type TypeVar -> Type [prec 0] .
  vars T1 T2 : Type .  var X : Id .
  eq T1{T2 / X} = substitute(T1, T2, X) .
endm

reduce int -> int .
reduce int{bool / s} .
reduce (s -> s){int / s} .
reduce (\/ s . s -> s){int / s} .
reduce (\/ s . s -> t){s -> s / t} .

mod SYSTEM-F-TYPE-SYSTEM-CONFIGURATIONS is including TYPE-ASSIGNMENT + SUBSTITUTION .
  sort Configuration .
  op <_,_,_> : TypeVariables TypeAssignment Exp -> Configuration .
  op <_> : Type -> Configuration .
endm

mod SYSTEM-F-TYPE-SYSTEM is including SYSTEM-F-TYPE-SYSTEM-CONFIGURATIONS .
  var L : TypeVariables .  var Gamma : TypeAssignment . var X : Var .
  var T T' : Type . var S : TypeVar . var E E' : Exp .

--- Variable
  --- TODO: this is only valid if free type variables in T are in L
  rl < L,  (Gamma & X |-> T), X > => < T > .

--- Variable Lambda Abstraction
  crl < L, Gamma, /\ X : T . E > => < T -> T' >
    if < L, Gamma[T / X], E > => < T' > .

--- Application
  crl < L, Gamma, (E E') > => < T ' >
    if < L, Gamma, E > => < S -> T > /\ < L, Gamma, E' > => < S > .

--- Type Abstraction
  crl < L, Gamma , (/\ S . E) > => < \/ S . T >
    if < L ; S, Gamma, E > => < T > .

--- Type Application
  crl < L, Gamma, E[T'] > => < T{T' / S} >
    if < L, Gamma, E > => < \/ S . T > .
endm

quit