mod IMP-SEMANTICS-EVALUATION-CONTEXTS is including IMP-SPLIT-PLUG-EVALUATION-CONTEXTS .
  var X : Id .  var I I' I1 I2 : Int .  var B B2 : BExp .  var S S1 S2 S3 : Stmt .  var P : Pgm .
  var Cfg Cfg' : Configuration .  var Syn Syn' : Syntax  .  var C : Context .

 crl o Cfg => Cfg' if plug(o split(Cfg)) => Cfg' .           --- generic rule enabling splitting
 crl o C[Syn] => C[Syn'] if C =/=Bool [] /\ o Syn => Syn' .  --- characteristic rule

*** <new> Rules/equations generated by the procedure in Section 3.7.2
--- Next rule generated because we have LHS's of the form let X = I in C[Syn]
 crl o let X = I in S => Syn' if plug(o let X = I in split(S)) => Syn' .
--- Next equation generated because we have RHS's of the form let X = I in C[Syn]
  eq plug(let X = I in C[Syn]) = let X = I in plug(C[Syn]) .
*** </new>

*** <new> This rule changed to lookup for variable in a let binding.
*** Only works when variables in nested let binders are distinct
  rl o let X = I in C[X] => let X = I in C[I] .
*** </new>

  rl o I1 + I2 => I1 +Int I2 .
 crl o I1 / I2 => I1 /Int I2 if I2 =/=Bool 0 .
  rl o I1 <= I2 => I1 <=Int I2 .
  rl o ! true  => false .
  rl o ! false => true  .
  rl o true  && B2 => B2 .
  rl o false && B2 => false .
  rl o C[{S}] => C[S] .

*** <new> This rule changed to assign variable in a let binding.
  rl o let X = I in C[X = I' ;] => let X = I' in C[{}] .
*** </new>

  rl o {} S2 => S2 .
  rl o if  (true) S1 else S2 => S1 .
  rl o if (false) S1 else S2 => S2 .
  rl o while (B) S => if (B) {S while (B) S} else {} .

*** <new> The rule for let
  rl o let X = I in {} => {} .
*** </new>

endm
