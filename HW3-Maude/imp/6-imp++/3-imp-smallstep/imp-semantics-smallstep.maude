mod IMP-CONFIGURATIONS-SMALLSTEP is including IMP-DESUGARED-SYNTAX + STATE .
  including BUFFER .

  sorts Configuration ExtendedConfiguration .
  subsort Configuration < ExtendedConfiguration .
  --- Add input buffers to all expression configurations
  op <_,_,_> : AExp State Buffer -> Configuration .
  op <_,_,_> : BExp State Buffer -> Configuration .

  --- Denotes division by zero
  op <`error`,_,_> : State Buffer -> Configuration .

  --- Add I/O buffers to statement configurations
  op <_,_,_,_> : Stmt State Buffer Buffer -> Configuration .
  --- Halting configurations
  op <`halting`,_,_,_> : State Buffer Buffer -> Configuration .

  op <_,_> : Pgm Buffer -> Configuration .
  op o_ : Configuration -> ExtendedConfiguration [prec 80] .   --- one step
  op *_ : Configuration -> ExtendedConfiguration [prec 80] .   --- all steps
  var Cfg Cfg' : Configuration .
  crl * Cfg => * Cfg' if o Cfg => Cfg' .
endm

mod IMP-SEMANTICS-SMALLSTEP is including IMP-CONFIGURATIONS-SMALLSTEP .
  var X : Id .  var Sigma Sigma' : State .  var I I1 I2 : Int .  var Xl : List{Id} .
  var A A' A1 A1' A2 A2' : AExp .  var B B' B1 B1' B2 : BExp .  var S S' S1 S1' S2 : Stmt .
  var Win Wout Win' : Buffer .

  crl o < X, Sigma, Win > => < Sigma(X), Sigma, Win >
    if Sigma(X) =/=Bool undefined .

--- Addition
  crl o < A1 + A2, Sigma, Win > => < A1' + A2, Sigma', Win' >
    if o < A1, Sigma, Win > => < A1', Sigma', Win' > .
  
  crl o < A1 + A2, Sigma, Win > => < A1 + A2', Sigma', Win' >
    if o < A2, Sigma, Win > => < A2', Sigma', Win' > .
  
  rl o < I1 + I2, Sigma, Win > => < I1 +Int I2, Sigma, Win > .

  crl o < A1 + A2, Sigma, Win > => < error, Sigma', Win' >
    if o < A1, Sigma, Win > => < error, Sigma', Win' > .
  
  crl o < A1 + A2, Sigma, Win > => < error, Sigma', Win' >
    if o < A2, Sigma, Win > => < error, Sigma', Win' > .

--- Division
  crl o < A1 / A2, Sigma, Win > => < A1' / A2, Sigma', Win' >
    if o < A1, Sigma, Win > => < A1', Sigma', Win' > .
  
  crl o < A1 / A2, Sigma, Win > => < A1 / A2', Sigma', Win' >
    if o < A2, Sigma, Win > => < A2', Sigma', Win' > .
  
  crl o < I1 / I2, Sigma, Win > => < I1 /Int I2, Sigma, Win >
    if I2 =/=Bool 0 .

  crl o < A1 / A2, Sigma, Win > => < error, Sigma', Win' >
    if o < A1, Sigma, Win > => < error, Sigma', Win' > .
  
  crl o < A1 / A2, Sigma, Win > => < error, Sigma', Win' >
    if o < A2, Sigma, Win > => < error, Sigma', Win' > .
  
  rl o < A1 / 0, Sigma, Win > => < error, Sigma, Win > .

--- Increment
  crl o < ++ X, Sigma, Win > => < Sigma(X) +Int 1, Sigma[(Sigma(X) +Int 1) / X], Win >
    if Sigma(X) =/=Bool undefined .

--- Read construct
  rl o < read(), Sigma, I : Win > => < I, Sigma, Win > .

--- Leq
  crl o < A1 <= A2, Sigma, Win > => < A1' <= A2, Sigma', Win' >
    if o < A1, Sigma, Win > => < A1', Sigma', Win' > .

  crl o < I1 <= A2, Sigma, Win > => < I1 <= A2', Sigma', Win' >
    if o < A2, Sigma, Win > => < A2', Sigma', Win' > .

  rl o < I1 <= I2, Sigma, Win > => < I1 <=Int I2, Sigma, Win > .

  crl o < A1 <= A2, Sigma, Win > => < error, Sigma', Win' >
    if o < A1, Sigma, Win > => < error, Sigma', Win' > .

  crl o < I1 <= A2, Sigma, Win > => < error, Sigma', Win' >
    if o < A2, Sigma, Win > => < error, Sigma', Win' > .

--- Negation
  crl o < ! B, Sigma, Win > => < ! B', Sigma', Win' >
    if o < B, Sigma, Win > => < B', Sigma', Win' > .

  rl o < ! true, Sigma, Win > => < false, Sigma, Win > .

  rl o < ! false, Sigma, Win > => < true, Sigma, Win > .

  crl o < ! B, Sigma, Win > => <  error, Sigma', Win' >
    if o < B, Sigma, Win > => < error, Sigma', Win' > .

--- Conjunction
  crl o < B1 && B2, Sigma, Win > => < B1' && B2, Sigma', Win' >
    if o < B1, Sigma, Win > => < B1', Sigma', Win' > .

  rl o < false && B2, Sigma, Win > => < false, Sigma, Win > .

  rl o < true && B2, Sigma, Win > => < B2, Sigma, Win > .

  crl o < B1 && B2, Sigma, Win > => < error, Sigma', Win' >
    if o < B1, Sigma, Win > => < error, Sigma', Win' > .

  --- rl o < {S},Sigma > => < S,Sigma > .

  --- crl o < X = A ;,Sigma > => < X = A' ;,Sigma > if o < A,Sigma > => < A',Sigma > .
  --- crl o < X = I ;,Sigma > => < {},Sigma[I / X] > if Sigma(X) =/=Bool undefined .

  --- crl o < S1 S2,Sigma > => < S1' S2,Sigma' > if o < S1,Sigma > => < S1',Sigma' > .
  --- rl o < {} S2,Sigma > => < S2,Sigma > .

  --- crl o < if (B) S1 else S2,Sigma > => < if (B') S1 else S2,Sigma >
  --- if o < B,Sigma > => < B',Sigma  > .
  --- rl o < if (true) S1 else S2,Sigma > => < S1,Sigma > .
  --- rl o < if (false) S1 else S2,Sigma > => < S2,Sigma > .

  --- rl o < while (B) S,Sigma > => < if (B) {S while (B) S} else {},Sigma > .

  --- rl o < int Xl ; S > => < S,(Xl |-> 0) > .

endm